#include "force.h"

// ----------------------------------------------------------------------------------------

// Weeks-Chandler-Andersen (WCA) potential
double CalcWCA(double sigmasq, double dijsq, double eps) {

    double inv_rsq_eff = sigmasq / dijsq;
    return 48. * eps / sigmasq *
           (pow(inv_rsq_eff, 7.) - 0.5 * pow(inv_rsq_eff, 4.));
}

// ----------------------------------------------------------------------------------------

// Magnetic dipole-dipole interactions
void CalcDipole(double mi[3], double mj[3], double dissq, double dij[3], double F_0, double f_mag[3]) {
	
	double dis = sqrt(dissq);
	
	double mimj = 0.;
	double mirij = 0.;
	double mjrij = 0.;
	
	for (int d = 0; d < dim; d++) {
		mimj += mi[d] * mj[d];
		mirij -= mi[d] * dij[d];
		mjrij -= mj[d] * dij[d];
	}
	
	for (int d = 0; d < dim; d++) {
		f_mag[d] = F_0 / pow(dissq, 2.) * (mirij / dis * mj[d] + mjrij / dis * mi[d] 
		         - (5. * mjrij * mirij / dissq - mimj) * (- dij[d]) / dis);
	}
}

// ----------------------------------------------------------------------------------------

// Calculates the repulsive (WCA) pair interactions between the particles.
// "f" is splitted in "f_ste" (f steric, i.e., WCA) and "f_mag" (f magnetic, i.e., dipole) 
// because "hi_mode = 1" applies HIs only to magnetic interactions.
double CalcPairSte(Particle *p_i, Particle *p_j) {

    double dij[3];
    double dissq = 0.;
   
    dissq = Distance(p_i, p_j, dij);     // See distance.c
	
	// For r > 2^(1/6) sigma_eff, where sigma_eff = (sigma_1 + sigma_2) / 2, the WCA potential vanishes. 
    if (sqrt(dissq) < pow(2., 1. / 6.) * (p_i->sigma + p_j->sigma) / 2.) {

        double fp = 
            CalcWCA(pow((p_i->sigma + p_j->sigma) / 2., 2.), dissq, eps_wca);     // See force.c

		if(hi_mode == 1) {
			for (int d = 0; d < dim; d++) {
				p_i->f_ste[d] += fp * dij[d];
				p_j->f_ste[d] -= fp * dij[d];
			}
		} else {
			for (int d = 0; d < dim; d++) {
				p_i->f[d] += fp * dij[d];
				p_j->f[d] -= fp * dij[d];
			}

		}
    }

    return dissq;
}

// ----------------------------------------------------------------------------------------

// Calculates the magnetic interactions between the particles.
// "f" is splitted in "f_ste" (f steric, i.e., WCA) and "f_mag" (f magnetic, i.e., dipole) 
// because "hi_mode = 1" applies HIs only to magnetic interactions.
double CalcPairMag(Particle *p_i, Particle *p_j) {

    double dij[3];
    double dissq = 0.;
    
    dissq = Distance(p_i, p_j, dij);     // See distance.c
	
	// To save computational cost. Unphysical, but we assume that we can neglect 
	// the influence of particles after "rcut_dipol_part" micromagnets 
	if(sqrt(dissq) < rcut_dipol_part * distance_poles) {
		
		double f_mag_temp[3] = {0., 0., 0.};
		CalcDipole(p_i->m, p_j->m, dissq, dij, F_dipol_0, f_mag_temp);     // See force.c
		
		if(hi_mode == 1) {
			for (int d = 0; d < dim; d++) {
				p_i->f_mag[d] -= f_mag_temp[d];
				p_j->f_mag[d] += f_mag_temp[d];
			}
		} else {
			for (int d = 0; d < dim; d++) {
				p_i->f[d] -= f_mag_temp[d];
				p_j->f[d] += f_mag_temp[d];
			}

		}
	}

    return dissq;
}

// ----------------------------------------------------------------------------------------

// Calculates the repulsive particle-wall interactions.
// The wall is generated by placing an imaginary mirror particle behind the wall which
// repells the real particle.
// "f" is splitted in "f_ste" (f steric, i.e., WCA) and "f_mag" (f magnetic, i.e., dipole) 
// because "hi_mode = 1" applies HIs only to magnetic interactions.
double CalcWall(Particle *p_i, Particle *Wall) {
	
	double dij[3];
    double dissq = 0.;
	
	// Checks which wall is inserted to correctly place the mirror
	// particle behind the right wall.
	int wall_orientation = 0;
	if (Wall->m[2] > pow(10., -10.)) {
		wall_orientation = 2;
	} else {
		wall_orientation = 1;
	}

	// Depending on the wall, two of the components of the mirror 
	// particle are equals to the components of the real particle
	for(int d = 0; d < dim; d++) {
		if (d != wall_orientation) {
			Wall->r[d] = p_i->r[d];
		}
	}	

    dissq = Distance(p_i, Wall, dij);     // See distance.c
	
    if (sqrt(dissq) < pow(2., 1. / 6.) * (Wall->sigma + p_i->sigma) / 2.) {

        double fp = 
            CalcWCA(pow((Wall->sigma + p_i->sigma) / 2., 2.), dissq, eps_wall);     // See force.c

		if (hi_mode == 1) {
			for (int d = 0; d < dim; d++) {
				p_i->f_ste[d] += fp * dij[d];
			}
		} else {
			for (int d = 0; d < dim; d++) {
				p_i->f[d] += fp * dij[d];
			}
		}
    }

    return dissq;
}

// ----------------------------------------------------------------------------------------

// Calculates the magnetic interactions between the particles and the micromagnets.
// "f" is splitted in "f_ste" (f steric, i.e., WCA) and "f_mag" (f magnetic, i.e., dipole) 
// because "hi_mode = 1" applies HIs only to magnetic interactions.
double CalcPole(Particle *p_i, Particle *pole_j) {
	
	double dij[3];
    double dissq = 0.;
    // See distance.c
    dissq = Distance(p_i, pole_j, dij);     // See distance.c
	
	CalcMomentPole(pole_j);     // See magnetics.c
	
	// To save computational cost. Unphysical, but we assume that we can neglect 
	// the influence of micromagnets with distance "rcut_dipol_poles * distance_poles"
	if (sqrt(dissq) < rcut_dipol_poles * distance_poles) {
			
		double f_mag_temp[3] = {0., 0., 0.};
		CalcDipole(p_i->m, pole_j->m, dissq, dij, F_dipol_0, f_mag_temp);     // See force.c
		
		if(hi_mode == 1) {
			for (int d = 0; d < dim; d++) {
				p_i->f_mag[d] -= f_mag_temp[d];
			}
		} else {
			for (int d = 0; d < dim; d++) {
				p_i->f[d] -= f_mag_temp[d];
			}
		}
	}
	
	return dissq;
}

// ----------------------------------------------------------------------------------------

// Main function to calculate the force WITHOUT Verlet lists. 
// Updates the Verlet lists when applied.
void CalcForce(Particle *P, Particle *Poles, Particle *Wall) {
	
// ----------------------------------------------------------------------------------------
//  Resets forces and moments
// ----------------------------------------------------------------------------------------

    if(hi_mode == 1) {
		
		Node *current = partInSim->next;
		while (current != NULL) {
		
			int i = current->value;
			
			for (int d = 0; d < dim; d++) {
				P[i].f_mag[d] = 0.;
				P[i].f_ste[d] = 0.;
			}
			CalcMomentPart(&(P[i]));     // See magnetics.c
			
			current = current->next;
		}
	} else {
		
		Node *current = partInSim->next;
		while (current != NULL) {
		
			int i = current->value;
			
			for (int d = 0; d < dim; d++) {
				P[i].f[d] = 0.;
			}
			CalcMomentPart(&(P[i]));     // See magnetics.c
			
			current = current->next;
		}
	}

	Node *current_1 = partInSim->next;
    while (current_1 != NULL) {
		
		int i = current_1->value;
		
// ----------------------------------------------------------------------------------------
//  Particle-particle interactions and updating of the Verlet lists
// ----------------------------------------------------------------------------------------	
		
		clearList(P[i].verList_ste);
		clearList(P[i].verList_mag);
		
        Node *current_j = current_1->next;
		while (current_j != NULL) {
		
			int j = current_j->value;
			
			double dissq = CalcPairSte(&(P[i]), &(P[j]));     // See force.c
			if (sqrt(dissq) <
                pow(2., 1. / 6.) * (P[i].sigma + P[j].sigma) / 2. + rcut_ver) {
                push(P[i].verList_ste, P[j].verList_ste->value);     // See lists.c
            }
			
			dissq = CalcPairMag(&(P[i]), &(P[j]));     // See force.c
			if (sqrt(dissq) < rcut_dipol_part * distance_poles + rcut_ver) {
				push(P[i].verList_mag, P[j].verList_mag->value);     // See lists.c
			}
			
			current_j = current_j->next;
		}		
		current_1 = current_1->next;
    }
	
// ----------------------------------------------------------------------------------------
//  Particle-wall interactions and updating of the Verlet lists of the walls
// ----------------------------------------------------------------------------------------	
	
	// Number of walls
	int k_max = 0;
	if(stationary_mode) {
		k_max = 1;
	} else {
		k_max = 3;
	}
	
	for(int k = 0; k < k_max; k++) {
		
		clearList(Wall[k].verList_ste);     // See lists.c
		
		Node *current_2 = partInSim->next;
		while (current_2 != NULL) {
		
			int i = current_2->value;
			
			double dissq = CalcWall(&(P[i]), &(Wall[k]));     // See force.c
			if (sqrt(dissq) < pow(2., 1. / 6.) * (P[i].sigma + Wall[k].sigma) / 2. + rcut_ver) {
				push(Wall[k].verList_ste, P[i].verList_ste->value);     // See lists.c
			}

			current_2 = current_2->next;
		}
	}
	
// ----------------------------------------------------------------------------------------
//  Particle-micromagnet interactions and updating of the Verlet lists of the micromagnets
// ----------------------------------------------------------------------------------------	

	for(int j = 0; j < num_poles[0] * num_poles[1]; j++) {
		
		clearList(Poles[j].verList_mag);     // See lists.c
		
		Node *current_3 = partInSim->next;
		while (current_3 != NULL) {
		
			int i = current_3->value; 
		
			double dissq = CalcPole(&(P[i]), &(Poles[j]));     // See force.c
			if (sqrt(dissq) < rcut_dipol_poles * distance_poles + rcut_ver) {
				push(Poles[j].verList_mag, P[i].verList_mag->value);     // See lists.c
			}
			
			current_3 = current_3->next;
		}
    }

// ----------------------------------------------------------------------------------------
//  Saves current positions to check if Verlet lists must be updated
// ----------------------------------------------------------------------------------------	
	
	Node *current_4 = partInSim->next;
    while (current_4 != NULL) {
		
		int i = current_4->value;
		
		for(int d = 0; d < dim; d++) {
			P[i].r_old[d] = P[i].r[d];
		}
		
		current_4 = current_4->next;
	}
}

// ----------------------------------------------------------------------------------------

// Main function to calculate the force WITH Verlet lists. 
void CalcForceWithVerlet(Particle *P, Particle *Poles, Particle *Wall) {

// ----------------------------------------------------------------------------------------
//  Resets forces and moments
// ----------------------------------------------------------------------------------------

    if(hi_mode == 1) {
		
		Node *current = partInSim->next;
		while (current != NULL) {
		
			int i = current->value;
			
			for (int d = 0; d < dim; d++) {
				P[i].f_mag[d] = 0.;
				P[i].f_ste[d] = 0.;
			}
			CalcMomentPart(&(P[i]));     // See magnetics.c
			
			current = current->next;
		}
	} else {
		
		Node *current = partInSim->next;
		while (current != NULL) {
		
			int i = current->value;
			
			for (int d = 0; d < dim; d++) {
				P[i].f[d] = 0.;
			}
			CalcMomentPart(&(P[i]));     // See magnetics.c
			
			current = current->next;
		}
	}

// ----------------------------------------------------------------------------------------
//  Particle-particle interactions 
// ----------------------------------------------------------------------------------------	

	Node *current = partInSim->next;
    while (current != NULL) {
		
		int i = current->value;
		
        Node *current_j = P[i].verList_ste->next;
        while (current_j != NULL) {

			int j = current_j->value;
			
			CalcPairSte(&(P[i]), &(P[j]));     // See force.c
			
			current_j = current_j->next;
		}
		
		current_j = P[i].verList_mag->next;
		while (current_j != NULL) {
			
			int j = current_j->value;
			
			CalcPairMag(&(P[i]), &(P[j]));     // See force.c
			
			current_j = current_j->next;
		}		
		current = current->next;
    }

// ----------------------------------------------------------------------------------------
//  Particle-wall interactions
// ----------------------------------------------------------------------------------------	
	
	// Number of walls
	int k_max = 0;
	if(stationary_mode) {
		k_max = 1;
	} else {
		k_max = 3;
	}
	
	for(int k = 0; k < k_max; k++) {
		
		Node *current_m = Wall[k].verList_ste->next;
		while (current_m != NULL) {

			int m = current_m->value;
			
			CalcWall(&(P[m]), &(Wall[k]));     // See force.c
			
			current_m = current_m->next;
		}
	}
	
// ----------------------------------------------------------------------------------------
//  Particle-micromagnet interactions
// ----------------------------------------------------------------------------------------	
	
	for(int j = 0; j < num_poles[0] * num_poles[1]; j++) {
		
		Node *current_i = Poles[j].verList_mag->next;
        while (current_i != NULL) { 

			int i = current_i->value;
			
			CalcPole(&(P[i]), &(Poles[j]));
			
			current_i = current_i->next;
		}
    }
}

// ----------------------------------------------------------------------------------------